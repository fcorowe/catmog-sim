<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Blinded">
<meta name="keywords" content="spatial interaction modelling, gravity modelling, flow data">

<title>A practical guide to spatial interaction modelling</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="region-quarto-template_files/libs/clipboard/clipboard.min.js"></script>
<script src="region-quarto-template_files/libs/quarto-html/quarto.js"></script>
<script src="region-quarto-template_files/libs/quarto-html/popper.min.js"></script>
<script src="region-quarto-template_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="region-quarto-template_files/libs/quarto-html/anchor.min.js"></script>
<link href="region-quarto-template_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="region-quarto-template_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="region-quarto-template_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="region-quarto-template_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="region-quarto-template_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">A practical guide to spatial interaction modelling</h1>
</div>


<div class="quarto-title-meta-author">
  <div class="quarto-title-meta-heading">Author</div>
  <div class="quarto-title-meta-heading">Affiliation</div>
  
    <div class="quarto-title-meta-contents">
    <p class="author">Blinded </p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            
          </p>
      </div>
  </div>

<div class="quarto-title-meta">

      
  
    
  </div>
  
<div>
  <div class="abstract">
    <div class="block-title">Abstract</div>
    <p>This document is only a demo explaining how to use the template.</p>
  </div>
</div>

<div>
  <div class="keywords">
    <div class="block-title">Keywords</div>
    <p>spatial interaction modelling, gravity modelling, flow data</p>
  </div>
</div>

</header>


<section id="sec-intro" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Introduction</h1>
<p>Spatial interaction models (SIMs) is a core tool to simulate flows between different locations in physical space. They are a valuable resource through which the geographic structure between locations encoded in aggregate flows of people, information and goods can be represented and understood. Intuitively, SIMs seek to capture the spatial interaction between places as a function of three components: origin attributes, destination attributes and their separation. Inspired by Newtonian concepts developed in physics, spatial flows between locations are conceived as the result of their proportional gravitational force and inverse association with spatial separation. Attributes of origin and destination locations are employed to represent gravitational forces pushing and pulling people, information and goods between specific locations. Various forms of distance and costs are used to represent the deterring effects of geographical separation on spatial flows.</p>
<p>SIMs are widely used for prediction and inference. They are used to make inference about the factors contributing to influence spatial flows. They have been used to understand the magnitude and direction of influence of individual and place-level attributes on geographic flows. Understanding the effect of these factors offers valuable evidence to inform the development of appropriate plans, strategies and interventions <span class="citation" data-cites="fotheringham_okelly1989">(<a href="#ref-fotheringham_okelly1989" role="doc-biblioref">Fotheringham and O’Kelly, 1989</a>)</span>. SIMs are also used to make predictions of the size of spatial flows. These predictions are normally used to assess the impact of interventions and creation of “what-if” scenarios, providing guidance for the identification of optimal locations and size for potential new service units [REF]. In this context, SIMs are often used to evaluate the impact of new bus stops, shopping stores, schools or housing units on their potential demand and traffic changes <span class="citation" data-cites="fotheringham_okelly1989">(<a href="#ref-fotheringham_okelly1989" role="doc-biblioref">Fotheringham and O’Kelly, 1989</a>)</span>. To these ends, SIMs have been used to address questions in a variety of settings, including retail, migration, transport, trade, commuting, school travel and more broadly urban planning.</p>
<p>Yet, the implementation of SIMs remains a challenge. Algorithms to calibrate the parameters of SIMs have remained locked away, either behind dense algebraic notation in dusty papers from the 1970s, or behind paywalls of commercial software <span class="citation" data-cites="rowe2024">(<a href="#ref-rowe2024" role="doc-biblioref">Rowe et al., 2024</a>)</span>. Additionally, <span class="citation" data-cites="rowe2024">Rowe et al. (<a href="#ref-rowe2024" role="doc-biblioref">2024</a>)</span> noted a dearth of knowledge within geographical education as SIMs are not widely taught in undergraduate programmes in the same way as, for instance, regression models are taught in economics or social psychology. This situation is argued to have occurred despite the availability of effective routines to calibrate SIMs via popular linear and general linear modelling frameworks, and as practical expediency is sacrificed at the expense of theoretical or technical prowess <span class="citation" data-cites="rowe2024">(<a href="#ref-rowe2024" role="doc-biblioref">Rowe et al., 2024</a>)</span>. The ways in which calibration procedures are presented as lengthy mathematical derivation or passing reference to ordinary least square tend to hamper accessibility for the easy implementation of SIMs.</p>
<p>This computational notebook contributes to redressing these issues. It aims to provide an intuitive, understandable and practical guide to estimate SIMs in a variety of modelling frameworks. It will include the necessary code to calibrate SIMs, using origin-destination travel-to-work data for the United Kingdom in R programming language. The code provided is generisable and can be adapted to different origin-destination flow data and contexts, including migration, student, transport, trade, currency, data transfer, vessel, shipment and freight flows.</p>
<p>The notebook is structured as follows. The next section sets out some fundamental concepts and definitions relating to SIMs. <a href="#sec-comenv" class="quarto-xref">Section&nbsp;3</a> identifies the libraries used before <a href="#sec-data" class="quarto-xref">Section&nbsp;4</a> describes the data. <a href="#sec-visualising" class="quarto-xref">Section&nbsp;5</a> illustrates key techniques to visualise complex spatial interaction data, and <a href="#sec-modelling" class="quarto-xref">Section&nbsp;6</a> shows and explains how to estimate SIMs using a range of modelling frameworks. It start with traditional mathematical and Ordinary Least Squares (OLS) approaches to more advanced statistical frameworks, such as Generalised Linear Mixed Models (GLMMs) and machine learning algorithms.</p>
</section>
<section id="context" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Context</h1>
<p>SIMs take various forms. Newtonian gravity models are probably the most widely known and used form of SIMs. Inspired by Newton’s law of gravity, the basic gravity version of these models assumes that the spatial flows or interactions between an origin (<span class="math inline">\(i\)</span>) and a destination <span class="math inline">\(j\)</span> is proportional to their masses (<span class="math inline">\(M_{i}\)</span> and <span class="math inline">\(M_{j}\)</span>) and inversely proportional to their separation (<span class="math inline">\(D_{ij}\)</span>). Locations are expected to interact in a positively reinforcing manner that is multiplicative of their masses, but to diminish with the intervening role of their separation. The parameters <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\gamma\)</span> reflect the proportional relationship between the masses and flows. The separation between locations is often represented by a distance decay function and is measured in terms of the distance, cost or time involved in the interaction. Generally, the model includes a constant (<span class="math inline">\(\kappa\)</span>) ensuring that the expected flows do not exceed their respective observed counts, and a parameter (<span class="math inline">\(\beta\)</span>) representing the deterring effect of geographical separation. The task is to estimate the parameters <span class="math inline">\(\kappa\)</span>, <span class="math inline">\(\mu\)</span>, <span class="math inline">\(\gamma\)</span> and <span class="math inline">\(\beta\)</span>. Following <span class="citation" data-cites="wilson1971">Wilson (<a href="#ref-wilson1971" role="doc-biblioref">1971</a>)</span>, a gravity model can be expressed as:</p>
<p><span id="eq-1"><span class="math display">\[
T_{ij} = \kappa \frac{M^{\mu}_{i} M^{\gamma}_{j}}{D^{\beta}_{ij} }
\tag{1}\]</span></span></p>
<p>SIMs have three key inputs: (1) a matrix of flows between a set of origins and destinations; (2) a measure of separation between origins and destinations; and, (3) measures of masses at origin and destination locations. The literature usually considers a family of SIMs taking four forms which refers to various constraints placed on parameters of the model <span class="citation" data-cites="wilson1971">(<a href="#ref-wilson1971" role="doc-biblioref">Wilson, 1971</a>)</span>. There is an <em>unconstrained</em> version which offers a measure of spatial separation, assuming that there is no information on the number of flows originating from each origin to each destination. The number of flows is thus estimated via SIMs using surrogate factors, such as population at the origin and destiination. Constrained versions are used to ensure that specific origin or destination observations are met. Three general formulations of constrained models are used: <em>production-constrained</em>, <em>attraction-constrained</em> and <em>doubly-constrained</em> models. <em>Production-constrained</em> versions are used to constrain a model to origin factors so that the predicted flows emanating from individual origins are in proportion to the relative attractiveness of each destination. <em>Attraction-constrained</em> versions do the same but constrain models to destination factors so that the predicted flows terminating at each destination are in proportion to the relative attactiveness at individual origins. <em>Doubly-constrained</em> versions combine these two sets of constraints to ensure predicted flows are equal to observed flows are constrained by both origin and destination factors.</p>
<p>Various modelling frameworks have been used to calibrate the parameters of SIMs. Originally, mathematical formulations were heavily used but these did not offer any ideas of uncertainty about the estimated parameters and were seen as deterministic. To mitigate this, statistical frameworks proliferated. A simple and widely used formulation is a linear model in which geographic flows are logged to meet the normality modelling assumptions, and OLS and maximum likelihood optimisation frameworks are used to estimate the model parameters. However, linear modelling has various constraints and cannot easily incorporate flow counts of zero, right-skewed distributions of flows and non-linear relationships between flows and the set of predictors. As result, more advanced modelling frameworks have been used to fit SIMs, including count data approaches such as Poison and Negative Binomial Models <span class="citation" data-cites="rowe2023urban">(<a href="#ref-rowe2023urban" role="doc-biblioref">Rowe et al., 2023</a>)</span>, Generalised Linear Mixed Models <span class="citation" data-cites="apariciocastro2023">(<a href="#ref-apariciocastro2023" role="doc-biblioref">Aparicio Castro et al., 2023</a>)</span> and more recently machine learning <span class="citation" data-cites="rowe2022">(<a href="#ref-rowe2022" role="doc-biblioref">Rowe et al., 2022</a>)</span> and deep learning models <span class="citation" data-cites="simini2021">(<a href="#ref-simini2021" role="doc-biblioref">Simini et al., 2021</a>)</span>. This computational notebook will provide a practical guide on how to implement these models using travel-to-work data for the UK. The next sections will first introduce the computational environment and data used for this purpose.</p>
</section>
<section id="sec-comenv" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Computation environment</h1>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># data management </span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"># spatial data management</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(sf)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co"># generalised mixed linear modelling</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(glmmTMB)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># data visualisation</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(scales)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(patchwork)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="fu">source</span>(<span class="st">"../../code/style/data-visualisation_theme.R"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="sec-data" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Data</h1>
<p>We use an origin-destination matrix capturing travel-to-work commuting flows from the 2021 Census for England and Wales. The data provide estimates on usual residents aged 16 years and over and in employment before the Census week at the Lower Tier Local Authority (LTLA) level. The estimates capture the movement of people between their LTLA area of residence and work. The data are available in a long origin-destination pair format. The first seven columns contain the core components of a spatial interaction dataset, including code and names for origin and destination locations, and the population count moving between a origin-destination pair. The remainder of the dataset comprises the origin and destination attributes, including the total population count and population counts by socioeconomic categories. Columns 9 to 19 contain the attributes at origins and columns 20 to 31 contain the attributes at destinations. Looking at the data frame vertically, the first row shown below displays the count of people who reported Hartlepool as their place of residence and work. The third row shows the count of people who were residing in Hartlepool but reported to travel to work in Middlesbrough.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># read data</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">read_csv</span>(<span class="st">"../../data/output/sim_uk-travel-to-work_2021.csv"</span>) <span class="sc">%&gt;%</span> </span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># rename variables</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rename</span>(</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">ltla_res_code =</span> <span class="st">"Lower tier local authorities code"</span>,</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">ltla_res_name =</span> <span class="st">"Lower tier local authorities label"</span>,</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">ltla_work_code =</span> <span class="st">"LTLA of workplace code"</span>,</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">ltla_work_name =</span> <span class="st">"LTLA of workplace label"</span>,</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">ltla_work_id_code =</span> <span class="st">"Place of work indicator (4 categories) code"</span>,</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">ltla_work_id_lbl =</span> <span class="st">"Place of work indicator (4 categories) label"</span>,</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">count =</span> <span class="st">"Count"</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">%&gt;%</span> </span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  <span class="co"># exclude the following observations:</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">filter</span>(<span class="sc">!</span>ltla_work_name <span class="sc">%in%</span> </span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">c</span>(<span class="st">"Does not apply"</span>, </span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>                    <span class="st">"Workplace is offshore installation"</span>, </span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>                    <span class="st">"Workplace is outside the UK"</span>) ) <span class="sc">%&gt;%</span> </span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>  <span class="co"># exclude the following variables:</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>( <span class="sc">-</span><span class="fu">c</span>(ltla_work_id_code, ltla_work_id_lbl) ) <span class="sc">%&gt;%</span> </span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>  <span class="co"># exclude stayers</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">filter</span>(ltla_res_code <span class="sc">!=</span> ltla_work_code) </span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(df, <span class="at">n =</span> <span class="dv">5</span> ) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 5 × 31
  ltla_res_code ltla_res_name ltla_work_code ltla_work_name   count population_o
  &lt;chr&gt;         &lt;chr&gt;         &lt;chr&gt;          &lt;chr&gt;            &lt;dbl&gt;        &lt;dbl&gt;
1 E06000001     Hartlepool    E06000002      Middlesbrough     1500        92338
2 E06000001     Hartlepool    E06000003      Redcar and Clev…   671        92338
3 E06000001     Hartlepool    E06000004      Stockton-on-Tees  4240        92338
4 E06000001     Hartlepool    E06000005      Darlington         398        92338
5 E06000001     Hartlepool    E06000007      Warrington           2        92338
# ℹ 25 more variables: higher_managerial_administrative_professional_o &lt;dbl&gt;,
#   lower_managerial_administrative_professional_o &lt;dbl&gt;, intermediate_o &lt;dbl&gt;,
#   small_employers_own_account_o &lt;dbl&gt;, lower_supervisory_technical_o &lt;dbl&gt;,
#   semi_routine_o &lt;dbl&gt;, routine_o &lt;dbl&gt;, never_worked_unemployed_o &lt;dbl&gt;,
#   ft_students_o &lt;dbl&gt;, no_qualifications_o &lt;dbl&gt;, level4_o &lt;dbl&gt;,
#   population_d &lt;dbl&gt;, higher_managerial_administrative_professional_d &lt;dbl&gt;,
#   lower_managerial_administrative_professional_d &lt;dbl&gt;, …</code></pre>
</div>
</div>
</section>
<section id="sec-visualising" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Visualising spatial interaction data</h1>
</section>
<section id="sec-modelling" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Estimating spatial interaction models</h1>
<p>This section focuses on how to calibrate spatial interaction models in the form of gravity models. It starts with the classical mathematical formulation, then moves to basic statistical frameworks and their extensions.</p>
<section id="mathematical-gravity-models" class="level2" data-number="6.1">
<h2 data-number="6.1" class="anchored" data-anchor-id="mathematical-gravity-models"><span class="header-section-number">6.1</span> Mathematical gravity models</h2>
<section id="unconstrained-model" class="level3" data-number="6.1.1">
<h3 data-number="6.1.1" class="anchored" data-anchor-id="unconstrained-model"><span class="header-section-number">6.1.1</span> Unconstrained model</h3>
<p>We start by implementing the mathematical formulation of gravity models using <a href="#eq-1" class="quarto-xref">Equation&nbsp;1</a>. We adopt the standard Newtonian formulation assuming that <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\gamma\)</span> equal to 1 and <span class="math inline">\(\beta\)</span> to -2, and fit an <em>unconstrained</em> model. Recall here that this model assumes that no information on flows is available. We use the population at origin and destination LDAs and distance between LDA centroids in kilometers to define this model. To assess the model’s predictive capacity, we graphically compare predicted flows <em>versus</em> observed flows. We focus on movements between LDAs, removing movements within LDAs with distance zero. A perfect model would product predicted flows displaying a perfect positive linear relationship with the orbserved flows. The figure below shows the unconstrained model results displaying little correspondence between the predicted and observed flows. The model predicts unrealistic flows of over 10 million which exceeds the size of the observed flows. This reflects the unconstrained nature of the model producing predictions based on distance, origin and destination only.</p>
<div id="fig-1" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Unconstrained model</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co"># assuming these parameters</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>mu <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>gamma <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>beta <span class="ot">&lt;-</span> <span class="dv">2</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>kappa <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co"># using equation 1 to estimate unconstrained model</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>df<span class="sc">$</span>predicted_flow <span class="ot">&lt;-</span> <span class="fu">round</span>( kappa <span class="sc">*</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  (df<span class="sc">$</span>population_o<span class="sc">^</span>mu <span class="sc">*</span> df<span class="sc">$</span>population_d<span class="sc">^</span>gamma) <span class="sc">/</span> (df<span class="sc">$</span>distance_km<span class="sc">^</span>beta) </span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="co"># predicted versus observed flows</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>df <span class="sc">%&gt;%</span> </span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>  <span class="co"># remove predictions</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>( distance_km <span class="sc">!=</span> <span class="dv">0</span>) <span class="sc">%&gt;%</span> </span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>( <span class="fu">aes</span>( <span class="at">x =</span> count, <span class="at">y =</span> predicted_flow)) <span class="sc">+</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>( <span class="at">alpha =</span> .<span class="dv">8</span>, <span class="fu">aes</span>(<span class="at">colour =</span> count, </span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>                              <span class="at">size =</span> <span class="fu">abs</span>(population_o <span class="sc">/</span> <span class="fl">1e1</span>)) ) <span class="sc">+</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>  <span class="co"># change axis label to a shorthand</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_y_continuous</span>(</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    <span class="at">labels =</span> <span class="fu">label_number</span>(<span class="at">scale_cut =</span> <span class="fu">cut_short_scale</span>())</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    ) <span class="sc">+</span> </span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_x_continuous</span>(</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    <span class="at">labels =</span> <span class="fu">label_number</span>(<span class="at">scale_cut =</span> <span class="fu">cut_short_scale</span>())</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    ) <span class="sc">+</span> </span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>  <span class="co"># change colour scale</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_colour_distiller</span>(<span class="at">palette =</span> <span class="st">"RdBu"</span>, <span class="at">direction =</span> <span class="sc">-</span><span class="dv">1</span>) <span class="sc">+</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">y =</span> <span class="st">"Predicted flow"</span>,</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>       <span class="at">x =</span> <span class="st">"Observed flow"</span>) <span class="sc">+</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_plot_tufte</span>() <span class="sc">+</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme</span>(<span class="at">legend.position =</span> <span class="st">"none"</span>,</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>        <span class="at">axis.text.y =</span> <span class="fu">element_text</span>(<span class="at">size =</span> <span class="dv">9</span>),</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>        <span class="at">axis.text.x =</span> <span class="fu">element_text</span>(<span class="at">size =</span> <span class="dv">9</span>),</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>        <span class="at">axis.title=</span><span class="fu">element_text</span>(<span class="at">size =</span> <span class="dv">11</span>)</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>        )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="region-quarto-template_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid figure-img" width="288"></p>
</figure>
</div>
</div>
</div>
<p>Note: Colour represents the size of observed counts. Point size represents the size of population at origins.</p>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Unconstrained model predicted versus observed flows
</figcaption>
</figure>
</div>
</section>
<section id="constrained-models" class="level3" data-number="6.1.2">
<h3 data-number="6.1.2" class="anchored" data-anchor-id="constrained-models"><span class="header-section-number">6.1.2</span> Constrained models</h3>
<p><em>Production-constrained model</em></p>
<p>To address these inconsistencies, we turn to constrained models and first focus on the production-constrained model. This model assumes that we observe the total flows from each origin but not those arriving in each destination. So we can use information on the total number of outflows to constrain the model and distribute the total outflows proportionally to the population of destinations, and as before, inversely proportional to distance.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Production-constrained model</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co"># total outflow from each origin</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>outflow <span class="ot">&lt;-</span> df <span class="sc">%&gt;%</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(ltla_res_code) <span class="sc">%&gt;%</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarize</span>(<span class="at">total_outflow =</span> <span class="fu">sum</span>(count)) <span class="sc">%&gt;%</span> </span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ungroup</span>()</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="co"># merge outflows with original data</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> df <span class="sc">%&gt;%</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">left_join</span>(outflow, <span class="at">by =</span> <span class="st">"ltla_res_code"</span>)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="co"># compute denominator for each origin</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> df <span class="sc">%&gt;%</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(ltla_res_code) <span class="sc">%&gt;%</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">kappa_production =</span> <span class="fu">sum</span>((population_d<span class="sc">^</span>gamma) <span class="sc">/</span> (distance_km<span class="sc">^</span>beta), </span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>                           <span class="at">na.rm =</span> <span class="cn">TRUE</span>)) <span class="sc">%&gt;%</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ungroup</span>()</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="co"># compute predicted flows</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> df <span class="sc">%&gt;%</span> <span class="fu">mutate</span>(</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>  <span class="at">production_constrained_flow =</span> </span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    total_outflow <span class="sc">*</span> ((population_d<span class="sc">^</span>gamma) <span class="sc">/</span> (distance_km<span class="sc">^</span>beta)) <span class="sc">/</span> </span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    kappa_production</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>  )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><em>Attraction-constrained model</em></p>
<p>Alternatively, we could assume we only have data on the total number of flows arriving at each destination but we have no information on the number of flows being generated from each origin. In such situations, we can use an attraction-constrained model as it uses the known information on total inflows for individual destinations and a set of surrogate variables to represent the total number of flows from each origin.</p>
<p><em>Doubly-constrained model</em></p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="region-quarto-template_files/figure-html/unnamed-chunk-8-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="statistical-gravity-models" class="level2" data-number="6.2">
<h2 data-number="6.2" class="anchored" data-anchor-id="statistical-gravity-models"><span class="header-section-number">6.2</span> Statistical gravity models</h2>
<section id="linear-regression-model" class="level3" data-number="6.2.1">
<h3 data-number="6.2.1" class="anchored" data-anchor-id="linear-regression-model"><span class="header-section-number">6.2.1</span> Linear regression model</h3>
</section>
<section id="log-linear-regression-model" class="level3" data-number="6.2.2">
<h3 data-number="6.2.2" class="anchored" data-anchor-id="log-linear-regression-model"><span class="header-section-number">6.2.2</span> Log-linear regression model</h3>
</section>
<section id="logistic-regression-model-with-aggregated-data" class="level3" data-number="6.2.3">
<h3 data-number="6.2.3" class="anchored" data-anchor-id="logistic-regression-model-with-aggregated-data"><span class="header-section-number">6.2.3</span> Logistic regression model with aggregated data</h3>
</section>
<section id="poisson-regression-model" class="level3" data-number="6.2.4">
<h3 data-number="6.2.4" class="anchored" data-anchor-id="poisson-regression-model"><span class="header-section-number">6.2.4</span> Poisson regression model</h3>
</section>
</section>
<section id="extensions" class="level2" data-number="6.3">
<h2 data-number="6.3" class="anchored" data-anchor-id="extensions"><span class="header-section-number">6.3</span> Extensions</h2>
<section id="including-push-pull-factors" class="level3" data-number="6.3.1">
<h3 data-number="6.3.1" class="anchored" data-anchor-id="including-push-pull-factors"><span class="header-section-number">6.3.1</span> Including push-pull factors</h3>
</section>
<section id="negative-binomial-regression-model" class="level3" data-number="6.3.2">
<h3 data-number="6.3.2" class="anchored" data-anchor-id="negative-binomial-regression-model"><span class="header-section-number">6.3.2</span> Negative binomial regression model</h3>
</section>
<section id="generalised-linear-mixed-gravity-models" class="level3" data-number="6.3.3">
<h3 data-number="6.3.3" class="anchored" data-anchor-id="generalised-linear-mixed-gravity-models"><span class="header-section-number">6.3.3</span> Generalised linear mixed gravity models</h3>
</section>
<section id="machine-learning-gravity-models" class="level3" data-number="6.3.4">
<h3 data-number="6.3.4" class="anchored" data-anchor-id="machine-learning-gravity-models"><span class="header-section-number">6.3.4</span> Machine learning gravity models</h3>
</section>
</section>
</section>
<section id="references" class="level1 unnumbered" data-number="7">


</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">7 References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-apariciocastro2023" class="csl-entry" role="listitem">
Aparicio Castro, A., A. Wiśniowski, and F. Rowe (2023), <span>“<a href="https://doi.org/10.1093/jrsssa/qnad127">A Bayesian approach to estimate annual bilateral migration flows for South America using census data</a>,”</span> <em>Journal of the Royal Statistical Society Series A: Statistics in Society</em>, 187(2), 410–435.
</div>
<div id="ref-fotheringham_okelly1989" class="csl-entry" role="listitem">
Fotheringham, A., and M. O’Kelly (eds.) (1989), <em>Spatial interaction models: Formulations and applications</em>, Kluwer Academic Publishers. Dordrechit.
</div>
<div id="ref-rowe2023urban" class="csl-entry" role="listitem">
Rowe, F., A. Calafiore, D. Arribas-Bel, K. Samardzhiev, and M. Fleischmann (2023), <span>“Urban exodus? <span class="nocase">Understanding human mobility in Britain during the COVID-19 pandemic using Meta-Facebook data</span>,”</span> <em>Population, Space and Place</em>, 29(1), e2637.
</div>
<div id="ref-rowe2024" class="csl-entry" role="listitem">
Rowe, F., R. Lovelace, and A. Dennett (2024), <span>“<a href="https://doi.org/10.4337/9781802203233.00019">Spatial interaction modelling: A manifesto</a>,”</span> Edward Elgar Publishing, pp. 177–196.
</div>
<div id="ref-rowe2022" class="csl-entry" role="listitem">
Rowe, F., M. Mahony, and S. Tao (2022), <span>“<a href="https://doi.org/10.48550/ARXIV.2204.09792">Assessing machine learning algorithms for near-real time bus ridership prediction during extreme weather</a>.”</span>
</div>
<div id="ref-simini2021" class="csl-entry" role="listitem">
Simini, F., G. Barlacchi, M. Luca, and L. Pappalardo (2021), <span>“<a href="https://doi.org/10.1038/s41467-021-26752-4">A Deep Gravity model for mobility flows generation</a>,”</span> <em>Nature Communications</em>, 12(1).
</div>
<div id="ref-wilson1971" class="csl-entry" role="listitem">
Wilson, A.G. (1971), <span>“<a href="https://doi.org/10.1068/a030001">A Family of Spatial Interaction Models, and Associated Developments</a>,”</span> <em>Environment and Planning A: Economy and Space</em>, 3(1), 1–32.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>